{"version":3,"file":"static/js/1018.d7ea0b8c.chunk.js","mappings":"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","sources":["Components/ImageUpload.js","utils/firebaseUtils.js"],"sourcesContent":["import React, { useState, useEffect, forwardRef, useImperativeHandle, useRef } from \"react\";\nimport shortid from \"shortid\";\nimport { ref as firebaseRef, getDownloadURL, listAll } from 'firebase/storage';\nimport { storage } from '../config';\nimport { useSelector } from 'react-redux'; // Import useSelector and useDispatch\nimport { selectDarkModeStatus } from '../redux/selectors/darkModeSelector'; \nimport { deleteAllImagesInFolder,deleteImages,uploadImages} from '../utils/firebaseUtils'\nimport { Card, CardContent, IconButton } from '@mui/material';\nimport DeleteIcon from '@mui/icons-material/Delete';\nimport { useSnackbar } from \"../context/SnackbarContext\";\nimport { STORAGES } from \"../constants\";\nimport { useLoader } from \"../context/LoaderContext\";\n\n\nconst ImageUpload = forwardRef(({entityId,storageFolder,title, maxImageCount=10, minImageCount, updateMode, disable }, ref) => {\n  const { setIsLoading } = useLoader();\n  const showSnackbar = useSnackbar();\n  const imageInputRef = useRef(null);\n  const [selectedFiles, setSelectedFiles] = useState([]);\n  const [uploadedFiles, setUploadedFiles] = useState([]);\n  const [newFiles, setNewFiles] = useState([]); // Track new files to be added\n  const isDarkModeOn = useSelector(selectDarkModeStatus); // Use useSelector to access isDarkModeOn\n  //console.log(\"Received props=> entityId:\", entityId, \"|storageFolder:\", storageFolder);\n  const [progressDelete, setProgressDelete] = useState(-1);\n  const [progressUpdate, setProgressUpdate] = useState(-1);\n  const [isUploadSuccessful, setIsUploadSuccessful] = useState(false);\n\n  console.log(\"Kyc enitity id \",entityId, disable)\n  const filesizes = (bytes, decimals = 2) => {\n    if (bytes === 0) return \"0 Bytes\";\n    const k = 1024;\n    const dm = decimals < 0 ? 0 : decimals;\n    const sizes = [\"Bytes\", \"KB\", \"MB\", \"GB\", \"TB\", \"PB\", \"EB\", \"ZB\", \"YB\"];\n    const i = Math.floor(Math.log(bytes) / Math.log(k));\n    return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + \" \" + sizes[i];\n  };\n\n  useEffect(() => {\n   // console.log(\"Fetching image for\",entityId)\n    if(entityId){\n      fetchStudioImages(entityId); // Fetch images when component mounts\n    }\n  }, [entityId]);\n\n  useEffect(() => {\n   // console.log(\"Selected files:\", selectedFiles);\n    if (maxImageCount && selectedFiles.length > maxImageCount) {\n      const truncatedFiles = selectedFiles.slice(0, maxImageCount);\n      alert(`Exceeded maxImageCount, keeping first ${maxImageCount} files.`);\n      imageInputRef.current.value = null;\n      setSelectedFiles(truncatedFiles);\n    }\n  }, [selectedFiles, maxImageCount]);\n  \n\n  const handleInputChange = (e) => {\n    // console.log(\"handleInputChange\")\n    const files = Array.from(e.target.files);\n    const updatedFiles = [];\n    // console.log(\"file array \",files.length)\n    files.forEach((file) => {\n      const reader = new FileReader();\n      reader.onloadend = () => {\n        updatedFiles.push({\n          id: shortid.generate(),\n          filename: file.name,\n          filetype: file.type,\n          fileimage: reader.result,\n          datetime: file.lastModifiedDate.toLocaleString(\"en-IN\"),\n          filesize: filesizes(file.size),\n          file: file, // Store the actual file object\n        });\n\n        if (updatedFiles.length === files.length) {\n          setSelectedFiles((prevFiles) => [...prevFiles, ...updatedFiles]);\n          setNewFiles(updatedFiles);\n          imageInputRef.current.value = null;\n          // console.log(\"New files in total\",setNewFiles.length)\n        }\n      };\n\n      reader.readAsDataURL(file);\n    });\n  };\n\n  const handleDeleteSelectedFile = (id) => {\n    if (window.confirm(\"Are you sure you want to delete this image?\")) {\n      setSelectedFiles((prevFiles) =>\n        prevFiles.filter((file) => file.id !== id)\n      );\n    }\n  };\n\n  const handleUploadSubmit = async () => {\n    if (!entityId) {\n      alert(\"No studio selected\");\n      return;\n    }\n\n    setProgressDelete(-1);\n    setProgressUpdate(-1);\n\n    try {\n      setIsLoading(true);\n      if (maxImageCount === 1 && selectedFiles.length >= minImageCount) {\n        // Delete all previous images in the folder\n        await deleteAllImagesInFolder(storageFolder, entityId);\n        await uploadImages(storageFolder,newFiles, entityId, setProgressUpdate);\n        showSnackbar(\"Image uploaded successfully\", \"success\");\n        setIsUploadSuccessful(true);\n      } else {\n        // Calculate images to delete and add\n        const { imagesToDelete, newImages } = calculateDelta(selectedFiles, uploadedFiles);\n\n        if (minImageCount && newImages.length < minImageCount) {\n          showSnackbar(`Minimum ${minImageCount} image(s) are required`, \"error\");\n          return;\n        }\n\n        // Delete images if there are any\n        if (imagesToDelete.length > 0) {\n          await deleteImages(storageFolder, imagesToDelete, entityId, setProgressDelete);\n          showSnackbar(\"Image(s) deleted successfully\", \"success\");\n        }\n\n        // Upload new images if there are any\n        if (newImages.length > 0) {\n          await uploadImages(storageFolder, newImages, entityId, setProgressUpdate);\n          showSnackbar(\"Image(s) uploaded successfully\", \"success\");\n        }\n        setIsUploadSuccessful(true);\n      }\n\n      imageInputRef.current.value = null;\n      // alert(\"Images Uploaded/Deleted\");\n    } catch (error) {\n      setIsUploadSuccessful(false);\n      console.error(\"Error uploading/deleting images:\", error);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  // Function to calculate images to delete and new images to upload\n  const calculateDelta = (selectedFiles, uploadedFiles) => {\n    const selectedFileIds = selectedFiles.map(file => file.id);\n    const uploadedFileIds = uploadedFiles.map(file => file.id);\n\n    const imagesToDelete = uploadedFiles.filter(file => !selectedFileIds.includes(file.id));\n    const newImages = selectedFiles.filter(file => !uploadedFileIds.includes(file.id));\n\n    return { imagesToDelete, newImages };\n  };\n\n\n  const fetchStudioImages = async (entityId) => {\n    setSelectedFiles([]);\n    setNewFiles([]);\n    try {\n      const folderPath = `${storageFolder}/${entityId}`;\n      console.log(folderPath)\n      const folderRef = firebaseRef(storage, folderPath);\n      const fileList = await listAll(folderRef);\n\n      const files = await Promise.all(\n        fileList.items.map(async (fileRef) => {\n          const downloadURL = await getDownloadURL(fileRef);\n\n          return {\n            id: fileRef.name,\n            filename: fileRef.name,\n            fileURL: downloadURL,\n          };\n        })\n      );\n      // console.log('File fetching',files);\n      setUploadedFiles(files); // Update the uploadedFiles state with fetched data\n      setSelectedFiles(files);\n    } catch (error) {\n      console.error('Error fetching user images:', error);\n    }\n  };\n\n  useImperativeHandle(ref, () => ({\n    isValid: () => {\n      if (minImageCount === 0) return true;\n      return isUploadSuccessful\n    },\n  }));\n\n  return (\n    <div className=\"fileupload-view\" style={{ display: 'flex', width: '100%', justifyContent: 'center' }}>\n      <div className=\"row justify-content-center m-0\" style={{ flex: '1',justifyContent: 'center' }}>\n        <div className=\"col-md-6\" style={{ flex: '1' ,justifyContent: 'center'}}>\n          <div className=\"card mt-5\">\n            <div className=\"card-body\" style={{ backgroundColor: isDarkModeOn ? '#333333' : 'white' }}>\n              <div className=\"kb-data-box\">\n                <div className=\"kb-modal-data-title\">\n                  <div className=\"kb-data-title\" style={{justifyContent:'center',flex: '1'}}>\n                    <h4>{title}</h4>\n                    <p>Max no of image(s):{maxImageCount} {storageFolder === STORAGES.STUDIOIMAGES && <p>Add at least 5 images</p>}</p>\n                  </div>\n                </div>\n                <div style={{  backgroundColor: isDarkModeOn ? '#333333' : 'white'}}>\n                  <div className=\"kb-file-upload\">\n                    <div className=\"file-upload-box\">\n                      <input\n                        ref={imageInputRef}\n                        type=\"file\"\n                        id=\"fileupload\"\n                        className=\"file-upload-input\"\n                        onChange={handleInputChange}\n                        multiple\n                      />\n\n                    </div>\n                  </div>\n                  <br></br>\n                  <div className=\"kb-attach-box mb-3\">\n                  <div className=\"row\">\n                    {entityId && selectedFiles.length > 0 ? (\n                      selectedFiles.map((file) => (\n                        \n                        <div key={file.id} className=\"col-6 col-md-3 mb-3\" style={{ position: 'relative' }}>\n                          \n                          <Card sx={{ maxWidth: 345 }}>\n                            {file.filename.match(/\\.(jpg|jpeg|png|gif|svg)$/i) ? (\n                              <div style={{ position: 'relative' }}>\n                                <img\n                                  src={file.fileimage ? file.fileimage : file.fileURL}\n                                  alt={file.filename}\n                                  className=\"card-img-top\"\n                                  style={{ maxHeight: \"150px\", objectFit: \"cover\" }}\n                                />\n                                <IconButton\n                                  aria-label=\"delete\"\n                                  disabled={disable}\n                                  onClick={() => handleDeleteSelectedFile(file.id)}\n                                  style={{ position: 'absolute', top: 0, right: 0, backgroundColor: 'rgba(255, 255, 255, 0.5)' }}\n                                >\n                                  <DeleteIcon style={{color:\"ff0000\"}}/>\n                                </IconButton>\n                              </div>\n                            ) : (\n                              <CardContent>\n                                <i className=\"far fa-file-alt\"></i>\n                              </CardContent>\n                            )}\n                          </Card>\n                        </div>\n                        \n                      ))\n                    ) : (\n                      <div className=\"col-12 text-center\">\n                        <p>No images selected</p>\n                      </div>\n                    )}\n                  </div>\n\n                  </div>\n\n                  \n                  <div className=\"kb-buttons-box\">\n                    <button\n                      type=\"button\"\n                      className=\"btn div-submit\"\n                      style={{ backgroundColor: isDarkModeOn ? '#892CDC' : 'black', color:'white'  }}\n                      onClick={handleUploadSubmit}\n                      disabled={disable}\n                    >\n                      Image Upload\n                    </button>\n                  </div>\n                </div>\n                {selectedFiles.length > 0 && (\n                  <div className=\"kb-attach-box\" hidden>\n                    <div className=\"row\">\n                    <hr />\n                    {selectedFiles.map((file) => (\n                      <div key={file.id} className=\"col-6 col-md-3 mb-3\">\n                      <div className=\"card\">\n                        {file.filename.match(/\\.(jpg|jpeg|png|gif|svg)$/i) ? (\n                          <img\n                            src={file.fileimage}\n                            alt={file.filename}\n                            className=\"card-img-top\"\n                            style={{ maxHeight: \"150px\", objectFit: \"cover\" }}\n                          />\n                        ) : (\n                          <div className=\"card-body\">\n                            <i className=\"far fa-file-alt\"></i>\n                          </div>\n                        )}\n                      </div>\n                    </div>\n                    ))}\n                    </div>\n                  </div>\n                )}\n              </div>\n              { progressDelete >= 0 && (\n                    <div>\n                        <p style={{ color: isDarkModeOn ? '#fff' : '#000' }}>\n                            Deleting images... {progressDelete.toFixed(2)}%\n                        </p>\n                        <progress \n                            value={progressDelete} \n                            max=\"100\" \n                            style={{\n                                color: isDarkModeOn ? '#fff' : '#000'\n                            }}\n                        >\n                            {progressDelete.toFixed(2)}%\n                        </progress>\n                    </div>\n                )}\n\n                { progressUpdate >= 0 && (\n                    <div>\n                        <p style={{ color: isDarkModeOn ? '#fff' : '#000' }}>\n                            Uploading images... {progressUpdate.toFixed(2)}%\n                        </p>\n                        <progress \n                            value={progressUpdate} \n                            max=\"100\" \n                            style={{\n                                color: isDarkModeOn ? '#fff' : '#000'\n                            }}\n                        >\n                            {progressUpdate.toFixed(2)}%\n                        </progress>\n                    </div>\n                )}\n\n                            </div>\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n});\n\n// Set default prop values\nImageUpload.defaultProps = {\n  maxImageCount: 5, // Default maximum image count\n  updateMode: false,\n  disable:false,\n};\n\nexport default ImageUpload;","import { doc, getDoc, setDoc, updateDoc, deleteDoc, collection, query, getDocs, where, getCountFromServer } from 'firebase/firestore';\nimport { db } from '../config';\nimport {ref,listAll,getDownloadURL,uploadBytes, deleteObject, uploadBytesResumable  } from \"firebase/storage\";\nimport { storage } from '../config';\nimport { BASEURL_DEV, BASEURL_PROD } from '../constants';\nimport secureLocalStorage from 'react-secure-storage';\n\nexport const setCreatorMode = async (uid) => {\n  const BASEURL = BASEURL_PROD;\n  const url = `${BASEURL}crud/getUserMode/${uid}`;\n  //console.log(\"creatorMode uid\", uid, url);\n  \n  try {\n    const response = await fetch(url);\n    const data = await response.json();\n\n    if (data.success) {\n      let mode = false;\n      if (data.data === true) {\n        mode = true;\n      }\n      //console.log(\"setCreatorMode: Is User a creator?\", mode);\n      secureLocalStorage.setItem('CreatorMode', mode);\n    } else {\n      console.log(\"Error: \", data.message || \"Unknown error\");\n      //secureLocalStorage.setItem('CreatorMode', false);\n    }\n    \n  } catch (error) {\n    console.log(\"Error fetching user mode: \", error);\n    secureLocalStorage.setItem('CreatorMode', false);\n  }\n}\n\nexport const fetchStudioEntities = async (studioId, entityType, setState) => {\n  const BASE_URL = BASEURL_PROD;\n  try {\n    const url = `${BASE_URL}crud/${studioId}/${entityType}/`;\n    console.log(url)\n    const response = await fetch(url);\n    const data = await response.json();\n\n    if (data.success) {\n      setState(data.data);\n    } else {\n      console.error(`Error fetching ${entityType}:`, data.error);\n    }\n  } catch (error) {\n    console.error(`Error fetching ${entityType}:`, error);\n  }\n};\n\n\nexport const getCreatorMode = async () => {\n  try{\n    const mode = secureLocalStorage.getItem('CreatorMode');\n    console.log(\"getCreatorMode \",mode)\n    if (mode){\n      return mode\n    }else{\n      return false\n    }\n  } \n  catch(error){\n    console.log(\" error\");\n    return false\n  }\n}\n\nexport const setGetCreatorModeOnMount = async (uid) => {\n  await setCreatorMode(uid);\n  return await getCreatorMode();\n};\n\n\n// Read operation with image URL\nexport const readDocumentWithImageUrl = async (collectionName, productId) => {\n    console.log(\"Debug \",`${collectionName}/${productId}`)\n    const storagePath = `${collectionName}/${productId}`;\n    const folderRef = ref(storage,storagePath);\n    try {\n        const result = await listAll(folderRef);\n        if (result.items.length > 0) {\n            const firstFileRef = result.items[0];\n            const url = await getDownloadURL(firstFileRef);\n            console.log('Debug URL:', url);\n            return url;\n          } else {\n            console.log('Debug No files found in the folder.');\n            return null;\n          }\n    } catch (error) {\n      console.error('Error getting image URL:', error);\n      return null;\n    }\n  };\n\n// Read operation\nexport const readDocument = async (collectionName, documentId) => {\n    const docRef = doc(db, collectionName, documentId);\n    const docSnapshot = await getDoc(docRef);\n    return docSnapshot.exists() ? docSnapshot.data() : null;\n};\n\n// Create or Update operation\nexport const saveDocument = async (collectionName, documentId, data) => {\n    const docRef = doc(db, collectionName, documentId);\n    await setDoc(docRef, data, { merge: true });\n    return data;\n};\n\n\nexport const handleSavePostOTPSuccess = async (collectionName, documentId, phoneNumber) => {\n  const docRef = doc(db, collectionName, documentId);\n  await updateDoc(docRef, {isPhoneNumberVerified:true,phoneNumber});\n  return true;\n};\n\n// Update specific fields in a document\nexport const updateDocumentFields = async (collectionName, documentId, fields) => {\n    const docRef = doc(db, collectionName, documentId);\n    await updateDoc(docRef, fields);\n    return { id: documentId, ...fields };\n};\n\n// Delete operation\nexport const deleteDocument = async (collectionName, documentId) => {\n    const docRef = doc(db, collectionName, documentId);\n    await deleteDoc(docRef);\n    return { id: documentId };\n};\n\n// Query operation\nexport const queryDocuments = async (collectionName, conditions) => {\n    const q = query(collection(db, collectionName, conditions));\n    const querySnapshot = await getDocs(q);\n    return querySnapshot.docs.map((doc) => ({ id: doc.id, ...doc.data() }));\n};\n\nexport const queryDocumentsCount = async (collectionName,field,operation,value) => {\n    console.log(\"Hiii \",collectionName,field,operation,value)\n    const q = query(collection(db, collectionName), where(field,operation,value));\n    const snapshot = await getCountFromServer(q);\n    return snapshot.data().count;\n};\n\n\n  // Function to delete all images in a folder\nexport  const deleteAllImagesInFolder = async (storageFolder, entityId) => {\n    /*\n    Description: Deletes all images in the specified folder associated with the given entityId.\n\n    Args:\n      storageFolder <string>: The folder path in the storage where the images are stored.\n      entityId <string>: The unique identifier of the entity whose images are to be deleted eg UserId,StudioId like thing.\n    */\n    const folderPath = `${storageFolder}/${entityId}`;\n    const folderRef = ref(storage, folderPath);\n    const fileList = await listAll(folderRef);\n\n    await Promise.all(fileList.items.map(async (fileRef) => {\n      await deleteObject(fileRef);\n    }));\n  };\n\n    // Function to delete all images in a folder\n  export  const deleteAllImagesInFolder2 = async (storageFolder, entityId,subfolder) => {\n    /*\n    Description: Deletes all images in the specified folder associated with the given entityId.\n\n    Args:\n      storageFolder <string>: The folder path in the storage where the images are stored.\n      entityId <string>: The unique identifier of the entity whose images are to be deleted eg UserId,StudioId like thing.\n    */\n    const folderPath = `${storageFolder}/${entityId}/${subfolder}`;\n    const folderRef = ref(storage, folderPath);\n    const fileList = await listAll(folderRef);\n\n    await Promise.all(fileList.items.map(async (fileRef) => {\n      await deleteObject(fileRef);\n    }));\n  };\n\n  // Function to delete images\nexport const deleteImages = async (storageFolder,imagesToDelete,entityId,setProgress,thirdFolder=null) => {\n    /*\n    Description: Deletes specific images associated with the given entityId.\n\n    Args:\n      imagesToDelete <array>: An array of image objects to be deleted.\n      storageFolder <string>: The folder path in the storage where the images are stored.\n      entityId <string>: UserId,StudioId like thing.\n    */\n    const total = imagesToDelete.length;\n    let done = 0;\n    await Promise.all(imagesToDelete.map(async (file) => {\n      let folderPath = `${storageFolder}/${entityId}/${file.filename}`;\n      if (thirdFolder){\n         folderPath = `${storageFolder}/${entityId}/${thirdFolder}/${file.filename}`;\n      }\n      const fileRefToDelete = ref(storage, folderPath);\n      await deleteObject(fileRefToDelete);\n      done += 1;\n      setProgress((done / total) * 100);\n    }));\n  };\n\n  // Function to upload new images\nexport const uploadImages = async (storageFolder, newImages, entityId,setProgress,thirdFolder=null) => {\n    /*\n    Description: Uploads new images associated with the given entityId.\n\n    Args:\n      newImages <array>: An array of new image objects to be uploaded.\n      storageFolder <string>: The folder path in the storage where the images are stored.\n      entityId <string>: UserId,StudioId like thing.\n    */\n   console.log(storageFolder,entityId)\n   const total = newImages.length;\n    let done = 0;\n    await Promise.all(newImages.map(async (newFileData) => {\n      let folderPath = `${storageFolder}/${entityId}`;\n      if (thirdFolder){\n         folderPath = `${storageFolder}/${entityId}/${thirdFolder}`;\n      }\n      const fileRef = ref(storage, `${folderPath}/${newFileData.file.name}`);\n      await uploadBytes(fileRef, newFileData.file);\n      done += 1;\n      setProgress((done / total) * 100);\n    }));\n  };\n\n  export const uploadImages2 = async (storageFolder, newImages, entityId, thirdFolder = null) => {\n    /*\n    Description: Uploads new images associated with the given entityId.\n  \n    Args:\n      newImages <FileList or Array>: An array of File objects to be uploaded.\n      storageFolder <string>: The folder path in the storage where the images are stored.\n      entityId <string>: UserId, StudioId, etc.\n      thirdFolder <string|null>: Optional subfolder.\n    */\n\n    let folderPath = `${storageFolder}/${entityId}`;\n    if (thirdFolder){\n      folderPath = `${storageFolder}/${entityId}/${thirdFolder}`;\n    }\n    console.log(newImages.name)\n    const storageRef =  ref(storage, `${folderPath}/${newImages.name}`);\n    uploadBytesResumable(storageRef, newImages).then((snapshot) => {\n      console.log('Uploaded a blob or file!');\n    });\n  };\n\n  export const uploadImages3 = async (storageFolder, newImages, entityId, thirdFolder = null) => {\n    /*\n    Description: Uploads new images associated with the given entityId.\n  \n    Args:\n      newImages <FileList or Array>: An array of File objects to be uploaded.\n      storageFolder <string>: The folder path in the storage where the images are stored.\n      entityId <string>: UserId, StudioId, etc.\n      thirdFolder <string|null>: Optional subfolder.\n    */\n\n    let folderPath = `${storageFolder}/${entityId}`;\n    if (thirdFolder){\n      folderPath = `${storageFolder}/${entityId}/${thirdFolder}`;\n    }\n    console.log(newImages.name)\n    const storageRef =  ref(storage, `${folderPath}/${newImages.name}`);\n    const uploadTask = uploadBytesResumable(storageRef, newImages);\n    uploadTask.on('state_changed',\n      (snapshot) => {\n        // Get task progress, including the number of bytes uploaded and the total number of bytes to be uploaded\n        const progress = (snapshot.bytesTransferred / snapshot.totalBytes) * 100;\n        console.log('Upload is ' + progress + '% done');\n        switch (snapshot.state) {\n          case 'paused':\n            console.log('Upload is paused');\n            break;\n          case 'running':\n            console.log('Upload is running');\n            break;\n        }\n      }, \n      (error) => {\n        // A full list of error codes is available at\n        // https://firebase.google.com/docs/storage/web/handle-errors\n        switch (error.code) {\n          case 'storage/unauthorized':\n            // User doesn't have permission to access the object\n            break;\n          case 'storage/canceled':\n            // User canceled the upload\n            break;\n          case 'storage/unknown':\n            // Unknown error occurred, inspect error.serverResponse\n            break;\n        }\n      }, \n      () => {\n        // Upload completed successfully, now we can get the download URL\n        getDownloadURL(uploadTask.snapshot.ref).then((downloadURL) => {\n          console.log('File available at', downloadURL);\n        });\n      }\n    );\n    \n  };\n\n\n  export const uploadImages4 = async (storageFolder, newImages, entityId, thirdFolder = null, onProgress, onComplete) => {\n    /*\n    Description: Uploads new images associated with the given entityId.\n  \n    Args:\n      newImages <FileList or Array>: An array of File objects to be uploaded.\n      storageFolder <string>: The folder path in the storage where the images are stored.\n      entityId <string>: UserId, StudioId, etc.\n      thirdFolder <string|null>: Optional subfolder.\n    */\n\n    let folderPath = `${storageFolder}/${entityId}`;\n    if (thirdFolder){\n      folderPath = `${storageFolder}/${entityId}/${thirdFolder}`;\n    }\n    console.log(newImages,newImages.name)\n    const storageRef =  ref(storage, `${folderPath}/${newImages.name}`);\n    const uploadTask = uploadBytesResumable(storageRef, newImages);\n    uploadTask.on('state_changed',\n      (snapshot) => {\n        // Get task progress, including the number of bytes uploaded and the total number of bytes to be uploaded\n        const totalBytes = snapshot.totalBytes;\n        const bytesTransferred = snapshot.bytesTransferred;\n        const progress = totalBytes > 0 ? ((bytesTransferred / totalBytes) * 100).toFixed(2) : -1;\n        onProgress(progress);\n        console.log('Upload is ' + progress + '% done');\n        switch (snapshot.state) {\n          case 'paused':\n            console.log('Upload is paused');\n            break;\n          case 'running':\n            console.log('Upload is running');\n            break;\n        }\n      }, \n      (error) => {\n        // A full list of error codes is available at\n        // https://firebase.google.com/docs/storage/web/handle-errors\n        switch (error.code) {\n          case 'storage/unauthorized':\n            // User doesn't have permission to access the object\n            break;\n          case 'storage/canceled':\n            // User canceled the upload\n            break;\n          case 'storage/unknown':\n            // Unknown error occurred, inspect error.serverResponse\n            break;\n        }\n      }, \n      () => {\n        // Upload completed successfully, now we can get the download URL\n        getDownloadURL(uploadTask.snapshot.ref).then((downloadURL) => {\n          console.log('File available at', downloadURL);\n          onComplete(downloadURL);\n        });\n\n      }\n    );\n    \n  };\n\n\n export const uploadOneImageAndGetURL = async (storageFolder, file, entityId) => {\n    try {\n      const folderPath = `${storageFolder}/${entityId}/${file.name}`;\n      console.log(folderPath)\n      const fileRef = ref(storage, folderPath);\n      \n      await uploadBytes(fileRef, file);\n  \n      const imageUrl = await getDownloadURL(fileRef);\n      console.log(imageUrl)\n      return imageUrl;\n    } catch (error) {\n      console.error('Error uploading file:', error);\n      throw error; \n    }\n  };\n  \n  export const getAllFilesFromFolder = async (storageFolder) => {\n    const folderPath = `${storageFolder}`;\n    const folderRef = ref(storage, folderPath);\n    \n    try {\n        const fileList = await listAll(folderRef);\n\n        const imageUrlsComprehensive = await Promise.all(\n          fileList.items.map(async (fileRef) => {\n            const downloadURL = await getDownloadURL(fileRef);\n  \n            return {\n              id: fileRef.name,\n              filename: fileRef.name,\n              fileURL: downloadURL,\n            };\n          })\n        );\n\n        // return imageUrls;\n        return imageUrlsComprehensive\n    } catch (error) {\n        console.error('Error retrieving images:', error);\n        throw error;\n    }\n};\n\n"],"names":["ImageUpload","forwardRef","_ref","ref","entityId","storageFolder","title","maxImageCount","minImageCount","updateMode","disable","setIsLoading","useLoader","showSnackbar","useSnackbar","imageInputRef","useRef","selectedFiles","setSelectedFiles","useState","uploadedFiles","setUploadedFiles","newFiles","setNewFiles","isDarkModeOn","useSelector","selectDarkModeStatus","progressDelete","setProgressDelete","progressUpdate","setProgressUpdate","isUploadSuccessful","setIsUploadSuccessful","console","log","filesizes","bytes","decimals","arguments","length","undefined","dm","i","Math","floor","parseFloat","pow","toFixed","useEffect","fetchStudioImages","truncatedFiles","slice","alert","concat","current","value","calculateDelta","selectedFileIds","map","file","id","uploadedFileIds","imagesToDelete","filter","includes","newImages","async","folderPath","folderRef","firebaseRef","storage","fileList","listAll","files","Promise","all","items","downloadURL","getDownloadURL","fileRef","name","filename","fileURL","error","useImperativeHandle","isValid","_jsx","className","style","display","width","justifyContent","children","flex","_jsxs","backgroundColor","STORAGES","STUDIOIMAGES","type","onChange","e","Array","from","target","updatedFiles","forEach","reader","FileReader","onloadend","push","shortid","filetype","fileimage","result","datetime","lastModifiedDate","toLocaleString","filesize","size","prevFiles","readAsDataURL","multiple","position","Card","sx","maxWidth","match","src","alt","maxHeight","objectFit","IconButton","disabled","onClick","handleDeleteSelectedFile","window","confirm","top","right","DeleteIcon","color","CardContent","deleteAllImagesInFolder","uploadImages","deleteImages","hidden","max","defaultProps","setCreatorMode","BASEURL","BASEURL_PROD","url","uid","response","fetch","data","json","success","mode","secureLocalStorage","setItem","message","fetchStudioEntities","studioId","entityType","setState","BASE_URL","setGetCreatorModeOnMount","getItem","getCreatorMode","readDocumentWithImageUrl","collectionName","productId","storagePath","firstFileRef","readDocument","documentId","docRef","doc","db","docSnapshot","getDoc","exists","saveDocument","setDoc","merge","handleSavePostOTPSuccess","phoneNumber","updateDoc","isPhoneNumberVerified","updateDocumentFields","fields","queryDocumentsCount","field","operation","q","query","collection","where","getCountFromServer","count","deleteObject","deleteAllImagesInFolder2","subfolder","setProgress","thirdFolder","total","done","fileRefToDelete","newFileData","uploadBytes","uploadImages4","onProgress","onComplete","storageRef","uploadTask","uploadBytesResumable","on","snapshot","totalBytes","bytesTransferred","progress","state","code","then","getAllFilesFromFolder"],"sourceRoot":""}